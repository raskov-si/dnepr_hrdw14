/*!
    \file порт coldfire
*/

#include <assert.h>
#include <stddef.h>
#include "reserv/core/inc/rsrv_typedef.h"
#include "rsrv_os.h"

/*=============================================================================================================*/

/*=============================================================================================================*/
/*!  \brief пересчет тактов uC/OS в таймауты в млсек  */
/*=============================================================================================================*/
static inline u32 ms_to_ticks(u32 ms)
{
    return ms * OS_TICKS_PER_SEC / 1000;
}

/*=============================================================================================================*/
/*!  \brief 

     \sa 
*/
/*=============================================================================================================*/
int rsrv_os_lock_create(TrsrvOsSem  *sem)
{
    sem = OSSemCreate(1);
    if (sem != NULL) {
        return RSRV_OK;
    }

    return RSRV_OS_ERR;
}


/*=============================================================================================================*/
/*!  \brief 

     \sa 
*/
/*=============================================================================================================*/
int rsrv_os_lock(TrsrvOsSem  *sem)
{
    uint8_t  code;

    assert(sem != NULL);

    OSSemPend(sem, 0, (INT8U*)&code);
    if ( code == OS_ERR_NONE) {
        return RSRV_OK;
    }

    return RSRV_OS_ERR;
}

/*=============================================================================================================*/
/*!  \brief 

     \sa 
*/
/*=============================================================================================================*/
int rsrv_os_unlock(TrsrvOsSem  *sem)
{
    assert(sem != NULL);

    int8_t  code = OSSemPost(sem);

    if ( code == OS_ERR_NONE) {
        return RSRV_OK;
    }

    return RSRV_OS_ERR;
}

/*=============================================================================================================*/
/*!  \brief Создает новый почтовый ящик */
/*=============================================================================================================*/
int rsrv_os_mbox_new(TrsrvOsMbox *mbox, void *msg)
{
    TrsrvOsMbox     tmp_mbox;
    
    tmp_mbox = OSMboxCreate(msg);
    
    if ( tmp_mbox != NULL ) {      
        *mbox = tmp_mbox;
        return 0;
    }
    
    return -1;    
}

/*=============================================================================================================*/
/*!  \brief Посылает в ящик сообщение      */
/*=============================================================================================================*/
int rsrv_os_mbox_post(TrsrvOsMbox *mbox, void *msg)
{
    int8_t         err;    
    TrsrvOsMbox    tmp_mbox = *mbox;
    
    err = OSMboxPost (tmp_mbox, msg);
    if (err == OS_ERR_NONE) {
      return 0;
    }      
      
    return -1;
}

/*=============================================================================================================*/
/*!  \brief Ждет пока сообщение упадет в ящик в течение заданного таймаута */
/*=============================================================================================================*/
int rsrv_os_mbox_fetch(TrsrvOsMbox *mbox, void **msg, uint32_t timeout)
{
    uint8_t       err;
    TrsrvOsMbox   tmp_mbox = *mbox;
    int32_t       ucos_timeout;

    if (timeout) {
        ucos_timeout = ms_to_ticks(timeout);
        if (!ucos_timeout) {
            ucos_timeout = 1;
        } else if (ucos_timeout > 65535) {
            ucos_timeout = 65535;
        }
    }

    *msg = OSMboxPend(tmp_mbox, ucos_timeout, (INT8U*)&err);
    
    if (err == OS_ERR_NONE) {
        return 0;
    } else if (err == OS_ERR_TIMEOUT ) {
        return 1; 
    }
       
    return -1;
}








/*=============================================================================================================*/

